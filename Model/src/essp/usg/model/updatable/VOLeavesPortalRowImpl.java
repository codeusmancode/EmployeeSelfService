package essp.usg.model.updatable;

import essp.usg.model.entity_objects.EOLeavesPortalImpl;
import essp.usg.model.updatable.common.VOLeavesPortalRow;

import java.math.BigDecimal;
import java.math.BigInteger;

import java.sql.CallableStatement;
import java.sql.Timestamp;

import java.sql.Types;

import java.time.LocalDate;

import java.time.temporal.ChronoUnit;

import java.util.ArrayList;
import java.util.Calendar;

import java.util.Date;
import java.util.GregorianCalendar;

import java.util.List;

import java.util.stream.Collectors;
import java.util.stream.IntStream;

import oracle.adf.share.ADFContext;

import oracle.jbo.RowSet;
import oracle.jbo.domain.Number;
import oracle.jbo.server.EntityImpl;
import oracle.jbo.server.ViewRowImpl;
// ---------------------------------------------------------------------
// ---    File generated by Oracle ADF Business Components Design Time.
// ---    Sat Mar 17 09:56:22 PKT 2018
// ---    Custom code may be added to this class.
// ---    Warning: Do not modify method signatures of generated methods.
// ---------------------------------------------------------------------
public class VOLeavesPortalRowImpl extends ViewRowImpl implements VOLeavesPortalRow {


    public static final int ENTITY_EOLEAVESPORTAL = 0;
    String[] months = { "JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC" };

    /**
     * AttributesEnum: generated enum for identifying attributes and accessors. DO NOT MODIFY.
     */
    protected enum AttributesEnum {
        SrNo,
        EmpId,
        EmpCode,
        Leavetype,
        FromDate,
        ToDate,
        FromT,
        ToT,
        CreatedBy,
        CreationDate,
        TotLvs,
        Approved,
        Remarks,
        DeptId,
        Cancel,
        UpdatedDate,
        VersionNumber,
        LeaveStatus,
        fromHours,
        toHours,
        fromMin,
        toMin,
        ampm,
        ampmTO,
        dayPart,
        usgesspappmodule_LeaveTypes1_1,
        usgesspappmodule_AMPM1_1,
        usgesspappmodule_FirstSecondHalf1_1;
        private static AttributesEnum[] vals = null; ;
        private static final int firstIndex = 0;

        protected int index() {
            return AttributesEnum.firstIndex() + ordinal();
        }

        protected static final int firstIndex() {
            return firstIndex;
        }

        protected static int count() {
            return AttributesEnum.firstIndex() + AttributesEnum.staticValues().length;
        }

        protected static final AttributesEnum[] staticValues() {
            if (vals == null) {
                vals = AttributesEnum.values();
            }
            return vals;
        }
    }


    public static final int SRNO = AttributesEnum.SrNo.index();
    public static final int EMPID = AttributesEnum.EmpId.index();
    public static final int EMPCODE = AttributesEnum.EmpCode.index();
    public static final int LEAVETYPE = AttributesEnum.Leavetype.index();
    public static final int FROMDATE = AttributesEnum.FromDate.index();
    public static final int TODATE = AttributesEnum.ToDate.index();
    public static final int FROMT = AttributesEnum.FromT.index();
    public static final int TOT = AttributesEnum.ToT.index();
    public static final int CREATEDBY = AttributesEnum.CreatedBy.index();
    public static final int CREATIONDATE = AttributesEnum.CreationDate.index();
    public static final int TOTLVS = AttributesEnum.TotLvs.index();
    public static final int APPROVED = AttributesEnum.Approved.index();
    public static final int REMARKS = AttributesEnum.Remarks.index();
    public static final int DEPTID = AttributesEnum.DeptId.index();
    public static final int CANCEL = AttributesEnum.Cancel.index();
    public static final int UPDATEDDATE = AttributesEnum.UpdatedDate.index();
    public static final int VERSIONNUMBER = AttributesEnum.VersionNumber.index();
    public static final int LEAVESTATUS = AttributesEnum.LeaveStatus.index();
    public static final int FROMHOURS = AttributesEnum.fromHours.index();
    public static final int TOHOURS = AttributesEnum.toHours.index();
    public static final int FROMMIN = AttributesEnum.fromMin.index();
    public static final int TOMIN = AttributesEnum.toMin.index();
    public static final int AMPM = AttributesEnum.ampm.index();
    public static final int AMPMTO = AttributesEnum.ampmTO.index();
    public static final int DAYPART = AttributesEnum.dayPart.index();
    public static final int USGESSPAPPMODULE_LEAVETYPES1_1 = AttributesEnum.usgesspappmodule_LeaveTypes1_1.index();
    public static final int USGESSPAPPMODULE_AMPM1_1 = AttributesEnum.usgesspappmodule_AMPM1_1.index();
    public static final int USGESSPAPPMODULE_FIRSTSECONDHALF1_1 =
        AttributesEnum.usgesspappmodule_FirstSecondHalf1_1.index();

    /**
     * This is the default constructor (do not remove).
     */
    public VOLeavesPortalRowImpl() {
    }

    /**
     * Gets EOLeavesPortal entity object.
     * @return the EOLeavesPortal
     */
    public EOLeavesPortalImpl getEOLeavesPortal() {
        return (EOLeavesPortalImpl) getEntity(ENTITY_EOLEAVESPORTAL);
    }

    /**
     * Gets the attribute value for SR_NO using the alias name SrNo.
     * @return the SR_NO
     */
    public Long getSrNo() {
        return (Long) getAttributeInternal(SRNO);
    }

    /**
     * Sets <code>value</code> as attribute value for SR_NO using the alias name SrNo.
     * @param value value to set the SR_NO
     */
    public void setSrNo(Long value) {
        setAttributeInternal(SRNO, value);
    }

    /**
     * Gets the attribute value for EMP_ID using the alias name EmpId.
     * @return the EMP_ID
     */
    public BigInteger getEmpId() {
        return (BigInteger) getAttributeInternal(EMPID);
    }

    /**
     * Sets <code>value</code> as attribute value for EMP_ID using the alias name EmpId.
     * @param value value to set the EMP_ID
     */
    public void setEmpId(BigInteger value) {
        setAttributeInternal(EMPID, value);
    }

    /**
     * Gets the attribute value for EMP_CODE using the alias name EmpCode.
     * @return the EMP_CODE
     */
    public Long getEmpCode() {
        return (Long) getAttributeInternal(EMPCODE);
    }

    /**
     * Sets <code>value</code> as attribute value for EMP_CODE using the alias name EmpCode.
     * @param value value to set the EMP_CODE
     */
    public void setEmpCode(Long value) {
        setAttributeInternal(EMPCODE, value);
    }

    /**
     * Gets the attribute value for LEAVETYPE using the alias name Leavetype.
     * @return the LEAVETYPE
     */
    public String getLeavetype() {
        return (String) getAttributeInternal(LEAVETYPE);
    }

    /**
     * Sets <code>value</code> as attribute value for LEAVETYPE using the alias name Leavetype.
     * @param value value to set the LEAVETYPE
     */
    public void setLeavetype(String value) {
        setAttributeInternal(LEAVETYPE, value);
    }

    /**
     * Gets the attribute value for FROM_DATE using the alias name FromDate.
     * @return the FROM_DATE
     */
    public Timestamp getFromDate() {
        return (Timestamp) getAttributeInternal(FROMDATE);
    }

    /**
     * Sets <code>value</code> as attribute value for FROM_DATE using the alias name FromDate.
     * @param value value to set the FROM_DATE
     */
    public void setFromDate(Timestamp value) {
        setAttributeInternal(FROMDATE, value);
    }

    /**
     * Gets the attribute value for TO_DATE using the alias name ToDate.
     * @return the TO_DATE
     */
    public Timestamp getToDate() {
        return (Timestamp) getAttributeInternal(TODATE);
    }

    /**
     * Sets <code>value</code> as attribute value for TO_DATE using the alias name ToDate.
     * @param value value to set the TO_DATE
     */
    public void setToDate(Timestamp value) {
        setAttributeInternal(TODATE, value);
    }


    /**
     * Gets the attribute value for the calculated attribute FromT.
     * @return the FromT
     */
    public String getFromT() {
        return (String) getAttributeInternal(FROMT);
    }

    /**
     * Gets the attribute value for the calculated attribute ToT.
     * @return the ToT
     */
    public String getToT() {
        return (String) getAttributeInternal(TOT);
    }

    /**
     * Gets the attribute value for CREATED_BY using the alias name CreatedBy.
     * @return the CREATED_BY
     */
    public String getCreatedBy() {
        return (String) getAttributeInternal(CREATEDBY);
    }

    /**
     * Sets <code>value</code> as attribute value for CREATED_BY using the alias name CreatedBy.
     * @param value value to set the CREATED_BY
     */
    public void setCreatedBy(String value) {
        setAttributeInternal(CREATEDBY, value);
    }

    /**
     * Gets the attribute value for CREATION_DATE using the alias name CreationDate.
     * @return the CREATION_DATE
     */
    public Timestamp getCreationDate() {
        return (Timestamp) getAttributeInternal(CREATIONDATE);
    }


    /**
     * Gets the attribute value for TOT_LVS using the alias name TotLvs.
     * @return the TOT_LVS
     */
    public BigDecimal getTotLvs() {
        return (BigDecimal) getAttributeInternal(TOTLVS);
    }

    /**
     * Sets <code>value</code> as attribute value for TOT_LVS using the alias name TotLvs.
     * @param value value to set the TOT_LVS
     */
    public void setTotLvs(BigDecimal value) {
        setAttributeInternal(TOTLVS, value);
    }

    /**
     * Gets the attribute value for APPROVED using the alias name Approved.
     * @return the APPROVED
     */
    public String getApproved() {
        return (String) getAttributeInternal(APPROVED);
    }

    /**
     * Sets <code>value</code> as attribute value for APPROVED using the alias name Approved.
     * @param value value to set the APPROVED
     */
    public void setApproved(String value) {
        setAttributeInternal(APPROVED, value);
    }

    /**
     * Gets the attribute value for REMARKS using the alias name Remarks.
     * @return the REMARKS
     */
    public String getRemarks() {
        return (String) getAttributeInternal(REMARKS);
    }

    /**
     * Sets <code>value</code> as attribute value for REMARKS using the alias name Remarks.
     * @param value value to set the REMARKS
     */
    public void setRemarks(String value) {
        setAttributeInternal(REMARKS, value);
    }

    /**
     * Gets the attribute value for DEPT_ID using the alias name DeptId.
     * @return the DEPT_ID
     */
    public String getDeptId() {
        return (String) getAttributeInternal(DEPTID);
    }

    /**
     * Sets <code>value</code> as attribute value for DEPT_ID using the alias name DeptId.
     * @param value value to set the DEPT_ID
     */
    public void setDeptId(String value) {
        setAttributeInternal(DEPTID, value);
    }

    /**
     * Gets the attribute value for CANCEL using the alias name Cancel.
     * @return the CANCEL
     */
    public String getCancel() {
        return (String) getAttributeInternal(CANCEL);
    }

    /**
     * Sets <code>value</code> as attribute value for CANCEL using the alias name Cancel.
     * @param value value to set the CANCEL
     */
    public void setCancel(String value) {
        setAttributeInternal(CANCEL, value);
    }

    /**
     * Gets the attribute value for UPDATED_DATE using the alias name UpdatedDate.
     * @return the UPDATED_DATE
     */
    public Timestamp getUpdatedDate() {
        return (Timestamp) getAttributeInternal(UPDATEDDATE);
    }


    /**
     * Gets the attribute value for VERSION_NUMBER using the alias name VersionNumber.
     * @return the VERSION_NUMBER
     */
    public BigDecimal getVersionNumber() {
        return (BigDecimal) getAttributeInternal(VERSIONNUMBER);
    }

    /**
     * Sets <code>value</code> as attribute value for VERSION_NUMBER using the alias name VersionNumber.
     * @param value value to set the VERSION_NUMBER
     */
    public void setVersionNumber(BigDecimal value) {
        setAttributeInternal(VERSIONNUMBER, value);
    }

    /**
     * Gets the attribute value for the calculated attribute LeaveStatus.
     * @return the LeaveStatus
     */
    public String getLeaveStatus() {
        return (String) getAttributeInternal(LEAVESTATUS);
    }

    /**
     * Gets the attribute value for the calculated attribute fromHours.
     * @return the fromHours
     */
    public Number getfromHours() {
        return (Number) getAttributeInternal(FROMHOURS);
    }

    /**
     * Sets <code>value</code> as the attribute value for the calculated attribute fromHours.
     * @param value value to set the  fromHours
     */
    public void setfromHours(Number value) {
        setAttributeInternal(FROMHOURS, value);
    }

    /**
     * Gets the attribute value for the calculated attribute toHours.
     * @return the toHours
     */
    public Number gettoHours() {
        return (Number) getAttributeInternal(TOHOURS);
    }

    /**
     * Sets <code>value</code> as the attribute value for the calculated attribute toHours.
     * @param value value to set the  toHours
     */
    public void settoHours(Number value) {
        setAttributeInternal(TOHOURS, value);
    }

    /**
     * Gets the attribute value for the calculated attribute fromMin.
     * @return the fromMin
     */
    public Number getfromMin() {
        return (Number) getAttributeInternal(FROMMIN);
    }

    /**
     * Sets <code>value</code> as the attribute value for the calculated attribute fromMin.
     * @param value value to set the  fromMin
     */
    public void setfromMin(Number value) {
        setAttributeInternal(FROMMIN, value);
    }

    /**
     * Gets the attribute value for the calculated attribute toMin.
     * @return the toMin
     */
    public Number gettoMin() {
        return (Number) getAttributeInternal(TOMIN);
    }

    /**
     * Sets <code>value</code> as the attribute value for the calculated attribute toMin.
     * @param value value to set the  toMin
     */
    public void settoMin(Number value) {
        setAttributeInternal(TOMIN, value);
    }

    /**
     * Gets the attribute value for the calculated attribute ampm.
     * @return the ampm
     */
    public String getampm() {
        return (String) getAttributeInternal(AMPM);
    }

    /**
     * Sets <code>value</code> as the attribute value for the calculated attribute ampm.
     * @param value value to set the  ampm
     */
    public void setampm(String value) {
        setAttributeInternal(AMPM, value);
    }

    /**
     * Gets the attribute value for the calculated attribute ampmTO.
     * @return the ampmTO
     */
    public String getampmTO() {
        return (String) getAttributeInternal(AMPMTO);
    }

    /**
     * Sets <code>value</code> as the attribute value for the calculated attribute ampmTO.
     * @param value value to set the  ampmTO
     */
    public void setampmTO(String value) {
        setAttributeInternal(AMPMTO, value);
    }

    /**
     * Gets the attribute value for the calculated attribute dayPart.
     * @return the dayPart
     */
    public String getdayPart() {
        return (String) getAttributeInternal(DAYPART);
    }

    /**
     * Sets <code>value</code> as the attribute value for the calculated attribute dayPart.
     * @param value value to set the  dayPart
     */
    public void setdayPart(String value) {
        setAttributeInternal(DAYPART, value);
    }

    /**
     * Gets the view accessor <code>RowSet</code> usgesspappmodule_LeaveTypes1_1.
     */
    public RowSet getusgesspappmodule_LeaveTypes1_1() {
        return (RowSet) getAttributeInternal(USGESSPAPPMODULE_LEAVETYPES1_1);
    }

    /**
     * Gets the view accessor <code>RowSet</code> usgesspappmodule_AMPM1_1.
     */
    public RowSet getusgesspappmodule_AMPM1_1() {
        return (RowSet) getAttributeInternal(USGESSPAPPMODULE_AMPM1_1);
    }

    /**
     * Gets the view accessor <code>RowSet</code> usgesspappmodule_FirstSecondHalf1_1.
     */
    public RowSet getusgesspappmodule_FirstSecondHalf1_1() {
        return (RowSet) getAttributeInternal(USGESSPAPPMODULE_FIRSTSECONDHALF1_1);
    }

    public int submitLeaveAction() {
        String empcode = ADFContext.getCurrent()
                                   .getSessionScope()
                                   .get("sess_empcode")
                                   .toString();
        Calendar c = new GregorianCalendar(); //calendar variable that will be used through out this method


        //leave type null check
        if (getLeavetype() == null)
            return 4;


        if (getLeavetype().equals("CPL"))
            return 27;//cannot apply cpl error
        //from-date null check
        if (getFromDate() == null)
            return 3;

        //If to date is before from date check
        if (getToDate() != null) {
            if (getToDate().before(getFromDate())) {
                return 10;
            }
        } else { //if use does not provide to date
            setToDate(getFromDate());
        }


        //check if user has already applied a leave
        boolean b = alreadyApplied(empcode,getFromDate(),getToDate());
        if (b){
            return 26;
        }
            
        
         
        //automatically set the  time
        if (getLeavetype().equals("SHL") || getLeavetype().equals("CLH") || getLeavetype().equals("OD") ||
            getLeavetype().equals("PLH") || getLeavetype().equals("SLH")) {

            if (getLeavetype().equals("SHL")) {
                if (getfromHours().intValue() == 0) {
                    return 20; //should provide from date time
                }

                if (gettoHours().intValue() == 0) { //if use does not selects to time then add 2 hours
                    c = new GregorianCalendar();
                    c.set(Calendar.HOUR, getfromHours().intValue());
                    c.set(Calendar.MINUTE, getfromMin().intValue());
                    c.set(Calendar.AM_PM, getampm().equals("AM") ? Calendar.AM : Calendar.PM);

                    c.add(Calendar.HOUR, 2);

                    settoHours(new Number(c.get(Calendar.HOUR)));
                    settoMin(new Number(c.get(Calendar.MINUTE)));
                    setampmTO(c.get(Calendar.AM_PM) == 0 ? "AM" : "PM");

                }
                //join the time with the date
                c = new GregorianCalendar();
                c.setTime(getFromDate());
                c.set(Calendar.HOUR, getfromHours().intValue());
                c.set(Calendar.MINUTE, getfromMin().intValue());
                c.set(Calendar.AM_PM, getampm().equals("AM") ? Calendar.AM : Calendar.PM);

                setFromDate(new Timestamp(c.getTimeInMillis()));


                //System.out.println(gettoHours().intValue() + ":" + gettoMin().intValue() + "" + getampmTO());
                c = new GregorianCalendar();
                c.setTime(getToDate());
                c.set(Calendar.HOUR, gettoHours().intValue());
                c.set(Calendar.MINUTE, gettoMin().intValue());
                c.set(Calendar.AM_PM, getampmTO().equals("AM") ? Calendar.AM : Calendar.PM);

                setToDate(new Timestamp(c.getTimeInMillis()));

            } else if (getLeavetype().equals("OD")) {
                if (getfromHours().intValue() == 0) {
                    return 20; //should provide from date time
                }
                if (gettoHours().intValue() == 0) {
                    return 22;
                }
                //append the time with date
                c = new GregorianCalendar();
                c.setTime(getFromDate());
                c.set(Calendar.HOUR, getfromHours().intValue());
                c.set(Calendar.MINUTE, getfromMin().intValue());
                c.set(Calendar.AM_PM, getampm().equals("AM") ? Calendar.AM : Calendar.PM);
                setFromDate(new Timestamp(c.getTimeInMillis()));

                c = new GregorianCalendar();
                c.setTime(getToDate());
                c.set(Calendar.HOUR, gettoHours().intValue());
                c.set(Calendar.MINUTE, gettoMin().intValue());
                c.set(Calendar.AM_PM, getampmTO().equals("AM") ? Calendar.AM : Calendar.PM);
                setToDate(new Timestamp(c.getTimeInMillis()));


            } else if (getLeavetype().equals("CLH") || getLeavetype().equals("PLH") || getLeavetype().equals("SLH")) {
                c = new GregorianCalendar();
                c.setTime(getFromDate());
                String startTime =
                    getTiming(empcode,
                              c.get(Calendar.DAY_OF_MONTH) + "-" + months[c.get(Calendar.MONTH)] + "-" +
                              c.get(Calendar.YEAR), "start");
                String endTime =
                    getTiming(empcode,
                              c.get(Calendar.DAY_OF_MONTH) + "-" + months[c.get(Calendar.MONTH)] + "-" +
                              c.get(Calendar.YEAR), "end");

                //append the time automatically
                if (getdayPart().equals("First Half")) {
                    c = new GregorianCalendar();
                    c.setTime(getFromDate());
                    c.set(Calendar.HOUR, Integer.parseInt(startTime.split(":")[0]));
                    c.set(Calendar.MINUTE, Integer.parseInt(startTime.split(":")[1]));
                    c.set(Calendar.AM_PM, startTime.split(":")[2].equals("AM") ? Calendar.AM : Calendar.PM);

                    setFromDate(new Timestamp(c.getTimeInMillis()));

                    c = new GregorianCalendar();
                    c.setTime(getFromDate());
                    c.add(Calendar.HOUR, 4);
                    c.add(Calendar.MINUTE, 30);
                    setToDate(new Timestamp(c.getTimeInMillis()));

                } else {
                    c = new GregorianCalendar();
                    c.setTime(getToDate());
                    c.set(Calendar.HOUR, Integer.parseInt(endTime.split(":")[0]));
                    c.set(Calendar.MINUTE, Integer.parseInt(endTime.split(":")[1]));
                    c.set(Calendar.AM_PM, endTime.split(":")[2].equals("AM") ? Calendar.AM : Calendar.PM);

                    setToDate(new Timestamp(c.getTimeInMillis()));

                    c = new GregorianCalendar();
                    c.setTime(getToDate());
                    c.add(Calendar.HOUR, -4);
                    c.add(Calendar.MINUTE, -30);
                    setFromDate(new Timestamp(c.getTimeInMillis()));

                }
            }
        }


        long timeDifference = getToDate().getTime() - getFromDate().getTime();
        int numberOfLeaves =
            (int) timeDifference / (1000 * 60 * 60 * 24) +
            (1); //because leave applied on the same date will return 0 days.

        //get sundays between
        int numOfSundays = sundayCountBetween(getFromDate(), getToDate());
        //System.out.println("Total Leaves to apply other then sunday: " + (numberOfLeaves - numOfSundays));
        //set number of leaves in VO
        setTotLvs(new BigDecimal(numberOfLeaves - numOfSundays));
        float balance = getLeaveBalance();

        /*low leave balance check other then short leave*/
        //System.out.println("Performing low leave balance other then short leave and OD (official Work) check");
        if (((numberOfLeaves - numOfSundays) > balance)) {
            if (!getLeavetype().equals("SHL") && !getLeavetype().equals("OD"))
                return 9; //low leave balance
        }

        //48 hour check-works perfect
        Calendar fromDate = new GregorianCalendar();
        fromDate.setTime(getFromDate());
        Calendar currentDate = getCurrentDate();
        if (fromDate.before(currentDate)) {
            /*if (!ADFContext.getCurrent()
                           .getSessionScope()
                           .get("sess_empcode")
                           .toString()
                           .equals("157355")) { //skipping this check for anfan manzoor.*/
            //System.out.println("performing 48 hour check");
            int hourCount = hourCount(getFromDate(), currentDate.getTime());
            if (hourCount > 48) {
                return 8; // hour count in case of back date leave application
            }
            //}
        }


        //employee should not be present on the day of applying leave
        if (getLeavetype().equals("CL") || getLeavetype().equals("PL") || getLeavetype().equals("SL")) {
            //System.out.println("Performing 'employee should not be present' check");
            if (fromDate.before(getCurrentDate())) {
                boolean present = isEmpAbsentOnDays(ADFContext.getCurrent()
                                                              .getSessionScope()
                                                              .get("sess_empcode")
                                                              .toString(), getFromDate(), getToDate());
                // System.out.println("employee present status on " + getFromDate() + " :" + present);
                if (present) {
                    return 6; //employee was present on any of the days on which he is attemptying applying leaves
                }
            }
        }


        //short leave count check;
        if (getLeavetype().equals("SHL")) {
            //System.out.println("performing short leave in current month check");
            int totalShlAvailedThisMonth = getSHLCount4CurrentMonth();
            if (totalShlAvailedThisMonth >= 2) {
                return 7; //short leave availed in this month
            }
            //missing minutes check in case of short leave missing minutes = 130
            int mm = getMissingMinutes(new java.sql.Date(getFromDate().getTime()));
            // System.out.println("missing minutes: " + mm);
            if (mm > 130) {
                return 5; // missing minutes are greater then 130 error
            }
        }
        System.out.println();


        return 1; //success
    }

    private boolean alreadyApplied(String empcode,Date startDate,Date endDate){
        boolean applied = false;
        List<Date> dates = getDatesBetween(startDate, endDate);
        for (Date d:dates){
            if (isLeave(empcode, d)>0){
                applied =  true;
                break;
            }
        }
        return applied;
    }
    private int isLeave(String empcode, Date d){
        CallableStatement cst = null;
        int numOFLeaves =0;
        Calendar c = new GregorianCalendar();
        c.setTime(d);
        String dat = c.get(Calendar.DAY_OF_MONTH) + "-" + months[c.get(Calendar.MONTH)] + "-" + c.get(Calendar.YEAR);
        try {
            cst = getDBTransaction().createCallableStatement("{? = call USTMS.xx_is_leave(?,?)}", 0);
            cst.registerOutParameter(1, Types.INTEGER);
            cst.setString(2, empcode);
            cst.setString(3, dat);
            cst.executeUpdate();
            numOFLeaves = cst.getInt(1);
        } catch (Exception ex) {
            
            ex.printStackTrace();
        }
        
        return numOFLeaves;
    }
    private boolean isEmpAbsentOnDays(String empcode, Date startDate, Date endDate) {

        List<Date> dates = getDatesBetween(startDate, endDate);
        boolean present = false;
        for (Date d : dates) {
            Calendar c = new GregorianCalendar();
            c.setTime(d);
            if (c.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {
                java.sql.Date sqlDate = new java.sql.Date(d.getTime());
//also cover SL and other absenses
                if (!getEmpDayStatus(empcode, sqlDate).equals("A")) { //IT CAN BE 'Z' IN CASE SQL FUNCION THROWS AN EXCEPTION. I HAVEN'T HANDELED IT YET.
                    //System.out.println(" log>> " + sqlDate.toString());
                    present = true;
                    break;
                }
            }
        }
        return present;
    }


    private String getEmpDayStatus(String empcode, java.sql.Date date) {
        CallableStatement cst = null;
        String status = "";
        Calendar c = new GregorianCalendar();
        c.setTime(date);
        String d = c.get(Calendar.DAY_OF_MONTH) + "-" + months[c.get(Calendar.MONTH)] + "-" + c.get(Calendar.YEAR);
        try {
            cst = getDBTransaction().createCallableStatement("{? = call USTMS.xx_cust_is_present(?,?)}", 0);
            cst.registerOutParameter(1, Types.VARCHAR);
            cst.setString(2, empcode);
            cst.setString(3, d);
            cst.executeUpdate();
            status = cst.getString(1);
        } catch (Exception ex) {
            status = "";
            ex.printStackTrace();
        }
        // System.out.println("status from database:" + status + "|" + empcode + "|");
        return status;
    }

    private String getTiming(String empcode, String date, String type) {
        CallableStatement cst = null;
        String status = "";
        try {
            cst = getDBTransaction().createCallableStatement("{? = call USTMS.getstartendtime(?,?,?)}", 0);
            cst.registerOutParameter(1, Types.VARCHAR);
            cst.setString(2, empcode);
            cst.setString(3, date);
            cst.setString(4, type);
            cst.executeUpdate();
            status = cst.getString(1);
        } catch (Exception ex) {
            status = "";
            ex.printStackTrace();
        }
        // System.out.println("status from database:" + status + "|" + empcode + "|");
        return status;
    }

    private boolean hasAlreadyApplied(String empcode, java.sql.Date fdate, java.sql.Date tdate) {
        CallableStatement cst = null;
        int count = 0;
        try {
            cst = getDBTransaction().createCallableStatement("{? = call USTMS.xx_cust_isleave_applied(?,?,?)}", 0);
            cst.registerOutParameter(1, Types.INTEGER);
            cst.setString(2, ADFContext.getCurrent()
                                       .getSessionScope()
                                       .get("sess_empcode")
                                       .toString());
            cst.setDate(3, fdate);
            cst.setDate(4, tdate);
            cst.executeUpdate();
            count = cst.getInt(1);
        } catch (Exception ex) {

            ex.printStackTrace();
        }

        return count > 0;
    }


    private int getSHLCount4CurrentMonth() {
        CallableStatement cst = null;
        int count = 0;
        try {
            cst = getDBTransaction().createCallableStatement("{? = call USTMS.xx_cust_get_shl_count(?)}", 0);
            cst.registerOutParameter(1, Types.INTEGER);
            cst.setString(2, ADFContext.getCurrent()
                                       .getSessionScope()
                                       .get("sess_empcode")
                                       .toString());

            cst.executeUpdate();
            count = cst.getInt(1);
        } catch (Exception ex) {
            count = 0;
            ex.printStackTrace();
        }
        return count;
    }

    private int getMissingMinutes(java.sql.Date d) {
        CallableStatement cst = null;
        int missingMins = 0;
        try {
            cst = getDBTransaction().createCallableStatement("{? = call USTMS.xx_cust_get_missing_mins(?,?)}", 0);
            cst.registerOutParameter(1, Types.INTEGER);
            cst.setString(2, ADFContext.getCurrent()
                                       .getSessionScope()
                                       .get("sess_empcode")
                                       .toString());
            cst.setDate(3, d);
            cst.executeUpdate();
            missingMins = cst.getInt(1);
        } catch (Exception ex) {
            missingMins = 0;
            ex.printStackTrace();
        }
        return missingMins;
    }

    private float getLeaveBalance() {
        CallableStatement cst = null;

        float balance = 99f;
        try {
            cst = getDBTransaction().createCallableStatement("{? = call USTMS.xx_cust_get_leave_bal(?,?)}", 0);
            cst.registerOutParameter(1, Types.FLOAT);
            cst.setString(2, ADFContext.getCurrent()
                                       .getSessionScope()
                                       .get("sess_empcode")
                                       .toString());
            cst.setString(3, getLeavetype());
            cst.executeUpdate();
            balance = cst.getFloat(1);
        } catch (Exception ex) {
            balance = 99f;
            ex.printStackTrace();
        }
        return balance;
    }

    private Calendar getCurrentDate() {
        Calendar currentDate = Calendar.getInstance();
        currentDate.set(Calendar.HOUR_OF_DAY, 0);
        currentDate.set(Calendar.MINUTE, 0);
        currentDate.set(Calendar.SECOND, 0);
        currentDate.set(Calendar.MILLISECOND, 0);
        return currentDate;
    }

    private int hourCount(Date startDate, Date endDate) {
        List<Date> dates = getDatesBetween(startDate, endDate);
        // System.out.println(dates + " hourCount");
        int hourCount = 0;
        for (Date d : dates) {
            Calendar c = new GregorianCalendar();
            c.setTime(d);
            if (c.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {
                if (!c.equals(getCurrentDate()))
                    hourCount += 24;

            }
        }
        return hourCount;
    }

    private int sundayCountBetween(Date startDate, Date endDate) {
        List<Date> dates = getDatesBetween(startDate, endDate);
        //System.out.println(dates + " sundayCountBetween");
        int sundayCount = 0;
        for (Date d : dates) {
            Calendar c = new GregorianCalendar();
            c.setTime(d);
            if (c.get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
                sundayCount += 1;

            }
        }
        return sundayCount;
    }

    private List<Date> getDatesBetween(Date startDate, Date endDate) {
        List<Date> datesInRange = new ArrayList<>();
        Calendar calendar = new GregorianCalendar();
        calendar.setTime(startDate);

        Calendar endCalendar = new GregorianCalendar();
        endCalendar.setTime(endDate);

        while (calendar.before(endCalendar)) {
            Date result = calendar.getTime();
            datesInRange.add(result);
            calendar.add(Calendar.DATE, 1);
        }

        //add end date into array list manually
        datesInRange.add(endCalendar.getTime());
        return datesInRange;
    }

}

